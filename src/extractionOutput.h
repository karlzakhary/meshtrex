// src/extractionOutput.h
#pragma once

#include "common.h"
#include "buffer.h" // Uses the revised Buffer struct
#include <utility> // For std::move

// Holds the geometry generated by the Extraction Pipeline
struct ExtractionOutput {
    Buffer globalVertexBuffer{};
    Buffer globalIndexBuffer{};
    Buffer globalEdgeMapBuffer{};
    Buffer globalVertexCountBuffer{};
    Buffer globalIndexCountBuffer{};
	Buffer meshletDescriptorBuffer{};
    Buffer meshletCountBuffer{};
    // Optional: Buffer for indirect draw commands generated by extraction
    // Buffer indirectDrawBuffer{}; // Keep commented if not used yet
    // Optional: Counts if not using indirect draw buffer
    uint32_t meshletCount = 0; // Actual count generated (e.g., read from counter)
    uint32_t vertexCount = 0; // Get from counter buffer instead
    uint32_t indexCount = 0; // Get from counter buffer instead
    // uint32_t drawCommandCount = 0; // For indirect draw

    // Store device handle needed for cleanup via RAII destructor
    VkDevice device = VK_NULL_HANDLE;

    // --- Constructors / Assignment / Destructor ---
    ExtractionOutput() = default; // Default constructor ok

    ~ExtractionOutput() {
        cleanup(); // Rely on destructor for RAII cleanup
    }

    // Prevent copying
    ExtractionOutput(const ExtractionOutput&) = delete;
    ExtractionOutput& operator=(const ExtractionOutput&) = delete;

    // Move constructor
    ExtractionOutput(ExtractionOutput&& other) noexcept:
    globalVertexBuffer(std::move(other.globalVertexBuffer)),
    globalIndexBuffer(std::move(other.globalIndexBuffer)),
    globalEdgeMapBuffer(std::move(other.globalEdgeMapBuffer)),
    globalVertexCountBuffer(std::move(other.globalVertexCountBuffer)),
    globalIndexCountBuffer(std::move(other.globalIndexCountBuffer)),
    meshletDescriptorBuffer(std::move(other.meshletDescriptorBuffer)),
    meshletCountBuffer(std::move(other.meshletCountBuffer)),
    //   indirectDrawBuffer(std::move(other.indirectDrawBuffer)), // Move if uncommented
    meshletCount(other.meshletCount),
    vertexCount(other.vertexCount),
    indexCount(other.indexCount),
    device(other.device)
    {
        // Nullify the moved-from object's handles (already done by Buffer move)
        // Reset potentially problematic members
        other.meshletCount = 0;
        other.vertexCount = 0;
        other.indexCount = 0;
        other.device = VK_NULL_HANDLE; // Prevent moved-from object's destructor from acting
    }

    // Move assignment operator
    ExtractionOutput& operator=(ExtractionOutput&& other) noexcept {
        if (this != &other) {
            // Cleanup existing resources owned by *this* object first
            cleanup();

            // Move resources from 'other'
            globalVertexBuffer = std::move(other.globalVertexBuffer);
            globalIndexBuffer = std::move(other.globalIndexBuffer);
            globalEdgeMapBuffer = std::move(other.globalEdgeMapBuffer);
            globalVertexCountBuffer = std::move(other.globalVertexCountBuffer);
            globalIndexCountBuffer = std::move(other.globalIndexCountBuffer);
            meshletDescriptorBuffer = std::move(other.meshletDescriptorBuffer);
            meshletCountBuffer = std::move(other.meshletCountBuffer);
            // indirectDrawBuffer = std::move(other.indirectDrawBuffer); // Move if uncommented
            meshletCount = other.meshletCount;
            vertexCount = other.vertexCount;
            indexCount = other.indexCount;
            device = other.device;

            // Nullify the moved-from object
            other.meshletCount = 0;
            other.vertexCount = 0;
            other.indexCount = 0;
            other.device = VK_NULL_HANDLE;
        }
        return *this;
    }


    // Cleanup method (called by destructor)
    void cleanup() {
        if (device == VK_NULL_HANDLE) return; // Check if already cleaned or moved from

        // destroyBuffer now takes Buffer& and nullifies handles internally
        destroyBuffer(globalVertexBuffer, device);
        destroyBuffer(globalIndexBuffer, device);
        destroyBuffer(globalEdgeMapBuffer, device);
        destroyBuffer(globalVertexCountBuffer, device);
        destroyBuffer(globalIndexCountBuffer, device);
        destroyBuffer(meshletDescriptorBuffer, device);
        destroyBuffer(meshletCountBuffer, device);
        // destroyBuffer(indirectDrawBuffer, device); // Cleanup if uncommented

        globalVertexBuffer = {}; // Reset struct members (optional but clean)
        globalIndexBuffer = {};
        globalEdgeMapBuffer = {};
        globalVertexCountBuffer = {};
        globalIndexCountBuffer = {};
        meshletDescriptorBuffer = {};
        meshletCountBuffer = {};
        // indirectDrawBuffer = {};
        meshletCount = 0;
        vertexCount = 0;
        indexCount = 0;
        device = VK_NULL_HANDLE; // Mark as cleaned up
    }

};

struct MeshletDescriptor {
   uint32_t vertexOffset;
   uint32_t vertexCount;
   uint32_t indexOffset;
   uint32_t primitiveCount;
};

struct VertexData {
    glm::vec4 position;
    // glm::vec4 normal;
};