#pragma once

#include "common.h"
#include "buffer.h"

// Holds the geometry generated by the Extraction Pipeline
struct ExtractionOutput {
    Buffer vertexBuffer{};
    Buffer indexBuffer{};
	Buffer meshletDescriptorBuffer{};
    // Optional: Buffer for indirect draw commands generated by extraction
    Buffer indirectDrawBuffer{};
    // Optional: Counts if not using indirect draw buffer
    uint32_t meshletCount = 0;
    uint32_t vertexCount = 0;
    uint32_t indexCount = 0;
    uint32_t drawCommandCount = 0; // For indirect draw

    // Add device/allocator handles if Buffer needs them for cleanup
    VkDevice device = VK_NULL_HANDLE;

    // Basic cleanup - assumes Buffer struct holds necessary info
    void cleanup() {
        if (device == VK_NULL_HANDLE) return;
        destroyBuffer(vertexBuffer, device); // Assumes destroyBuffer exists
        destroyBuffer(indexBuffer, device);
        destroyBuffer(indirectDrawBuffer, device); // Check handle before destroying
        destroyBuffer(meshletDescriptorBuffer, device);
        vertexBuffer.buffer = VK_NULL_HANDLE;
        indexBuffer.buffer = VK_NULL_HANDLE;
        indirectDrawBuffer.buffer = VK_NULL_HANDLE;
		meshletDescriptorBuffer.buffer = VK_NULL_HANDLE;
        device = VK_NULL_HANDLE; // Indicate cleaned up
    }

    ~ExtractionOutput() {
         cleanup();
    }
    // Add move constructors/assignment if needed
};

// Define the structure that Pipeline 2 writes into meshletDescriptorBuffer
// This needs to match what the Rendering Task Shader (Pipeline 3) reads.
// Based loosely on common practices, details might vary based on paper/implementation.
struct MeshletDescriptor {
   uint32_t vertexOffset;    // Offset into the global vertexBuffer
   uint32_t indexOffset;     // Offset into the global indexBuffer
   uint32_t vertexCount;     // Number of vertices in this meshlet
   uint32_t primitiveCount;  // Number of triangles in this meshlet
   // Optional Bounding Box for culling (calculated in Pipeline 2)
   // float bounding_box_min[3];
   // float bounding_box_max[3];
   // Optional Normal Cone info etc.
};