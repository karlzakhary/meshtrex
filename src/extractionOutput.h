// src/extractionOutput.h
#pragma once

#include "common.h"
#include "buffer.h" // Uses the revised Buffer struct
#include <utility> // For std::move

// Holds the geometry generated by the Extraction Pipeline
struct ExtractionOutput {
    Buffer vertexBuffer{};
    Buffer vertexCountBuffer{};
    Buffer indexBuffer{};
    Buffer indexCountBuffer{};
	Buffer meshletDescriptorBuffer{};
    Buffer meshletDescriptorCountBuffer{};
    // Buffer for indirect draw commands generated by extraction
    Buffer indirectDrawBuffer{};
    // Optional: Counts if not using indirect draw buffer
    uint32_t meshletCount = 0; // Actual count generated (e.g., read from counter)
    uint32_t vertexCount = 0; // Get from counter buffer instead
    uint32_t indexCount = 0; // Get from counter buffer instead
    // uint32_t drawCommandCount = 0; // For indirect draw

    // Store device handle needed for cleanup via RAII destructor
    VkDevice device = VK_NULL_HANDLE;

    // --- Constructors / Assignment / Destructor ---
    ExtractionOutput() = default; // Default constructor ok

    ~ExtractionOutput() {
        cleanup(); // Rely on destructor for RAII cleanup
    }

    // Prevent copying
    ExtractionOutput(const ExtractionOutput&) = delete;
    ExtractionOutput& operator=(const ExtractionOutput&) = delete;

    // Move constructor
    ExtractionOutput(ExtractionOutput&& other) noexcept:
    vertexBuffer(std::move(other.vertexBuffer)),
    vertexCountBuffer(std::move(other.vertexCountBuffer)),
    indexBuffer(std::move(other.indexBuffer)),
    indexCountBuffer(std::move(other.indexCountBuffer)),
    meshletDescriptorBuffer(std::move(other.meshletDescriptorBuffer)),
    meshletDescriptorCountBuffer(std::move(other.meshletDescriptorCountBuffer)),
    indirectDrawBuffer(std::move(other.indirectDrawBuffer)),
    meshletCount(other.meshletCount),
    device(other.device)
    {
        // Nullify the moved-from object's handles (already done by Buffer move)
        // Reset potentially problematic members
        other.meshletCount = 0;
        other.vertexCount = 0;
        other.indexCount = 0;
        other.device = VK_NULL_HANDLE; // Prevent moved-from object's destructor from acting
    }

    // Move assignment operator
    ExtractionOutput& operator=(ExtractionOutput&& other) noexcept {
        if (this != &other) {
            // Cleanup existing resources owned by *this* object first
            cleanup();

            // Move resources from 'other'
            vertexBuffer = std::move(other.vertexBuffer);
            vertexCountBuffer = std::move(other.vertexCountBuffer);
            indexBuffer = std::move(other.indexBuffer);
            indexCountBuffer = std::move(other.indexCountBuffer);
            meshletDescriptorBuffer = std::move(other.meshletDescriptorBuffer);
            meshletDescriptorCountBuffer = std::move(other.meshletDescriptorCountBuffer);
            indirectDrawBuffer = std::move(other.indirectDrawBuffer);
            meshletCount = other.meshletCount;
            vertexCount = other.vertexCount;
            indexCount = other.indexCount;
            device = other.device;

            // Nullify the moved-from object
            other.meshletCount = 0;
            other.vertexCount = 0;
            other.indexCount = 0;
            other.device = VK_NULL_HANDLE;
        }
        return *this;
    }


    // Cleanup method (called by destructor)
    void cleanup() {
        if (device == VK_NULL_HANDLE) return; // Check if already cleaned or moved from

        // destroyBuffer now takes Buffer& and nullifies handles internally
        destroyBuffer(vertexBuffer, device);
        destroyBuffer(vertexCountBuffer, device);
        destroyBuffer(indexBuffer, device);
        destroyBuffer(indexCountBuffer, device);
        destroyBuffer(meshletDescriptorBuffer, device);
        destroyBuffer(meshletDescriptorCountBuffer, device);
        destroyBuffer(indirectDrawBuffer, device);

        vertexBuffer = {}; // Reset struct members (optional but clean)
        vertexCountBuffer = {};
        indexBuffer = {};
        indexCountBuffer = {};
        meshletDescriptorBuffer = {};
        meshletDescriptorCountBuffer = {};
        indirectDrawBuffer = {};
        meshletCount = 0;
        vertexCount = 0;
        indexCount = 0;
        device = VK_NULL_HANDLE; // Mark as cleaned up
    }

};

struct MeshletDescriptor {
   uint32_t vertexOffset;
   uint32_t indexOffset;
   uint32_t vertexCount;
   uint32_t primitiveCount;
};

struct VertexData {
    glm::vec4 position;
    glm::vec4 normal;
};